#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
漏洞测试脚本
用于测试和演示各个漏洞测试模块的功能
"""

import asyncio
import argparse
import json
import sys
import logging
from playwright.async_api import async_playwright

# 导入Agent类和测试模块
from agent import Agent
from modules.testers import TESTER_MAP

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("vulnerability_test.log", encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("vulnerability_test")

async def run_vulnerability_test(url, vulnerability_type, headless=True):
    """运行指定类型的漏洞测试"""
    if vulnerability_type not in TESTER_MAP:
        logger.error(f"不支持的漏洞类型: {vulnerability_type}")
        logger.info(f"支持的漏洞类型: {list(TESTER_MAP.keys())}")
        return
    
    logger.info(f"开始测试URL: {url} 的 {vulnerability_type} 漏洞")
    
    async with async_playwright() as playwright:
        # 初始化浏览器
        browser = await playwright.chromium.launch(headless=headless)
        context = await browser.new_context(
            viewport={"width": 1280, "height": 800},
            user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        )
        page = await context.new_page()
        
        # 创建Agent并访问目标网站
        agent = Agent(page)
        await agent.goto(url, wait_for_load=True)
        
        # 初始化测试模块并执行测试
        tester_class = TESTER_MAP[vulnerability_type]
        tester = tester_class(agent)
        
        # 运行测试
        results = await tester.test({"url": url})
        
        # 打印测试结果
        logger.info(f"测试完成，结果状态: {results['status']}")
        
        # 打印测试步骤记录
        logger.info("测试步骤记录:")
        for step in results.get("steps", []):
            logger.info(f"  [{step['status']}] {step['step']}: {step['message']}")
        
        # 打印发现的漏洞
        vulnerabilities = results.get("vulnerabilities", [])
        if vulnerabilities:
            logger.info(f"发现 {len(vulnerabilities)} 个漏洞:")
            for vuln in vulnerabilities:
                logger.info(f"  - {vuln.get('details', '未知漏洞')}")
                if 'payload' in vuln:
                    logger.info(f"    使用载荷: {vuln['payload']}")
        else:
            logger.info("未发现漏洞")
        
        # 关闭浏览器
        await browser.close()
        
        return results

def save_results(results, output_file):
    """将测试结果保存到文件"""
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, ensure_ascii=False, indent=2)
        logger.info(f"测试结果已保存到: {output_file}")
    except Exception as e:
        logger.error(f"保存结果时出错: {str(e)}")

def parse_arguments():
    """解析命令行参数"""
    parser = argparse.ArgumentParser(description="Web漏洞测试工具")
    parser.add_argument("url", help="要测试的目标URL")
    parser.add_argument(
        "-t", "--type", 
        choices=list(TESTER_MAP.keys()), 
        default="sql_injection", 
        help="要测试的漏洞类型"
    )
    parser.add_argument(
        "--visible", 
        action="store_true", 
        help="显示浏览器窗口（默认隐藏）"
    )
    parser.add_argument(
        "-o", "--output", 
        help="结果输出文件（JSON格式）"
    )
    return parser.parse_args()

async def main():
    # 解析命令行参数
    args = parse_arguments()
    
    # 运行测试
    results = await run_vulnerability_test(
        args.url, 
        args.type, 
        headless=not args.visible
    )
    
    # 保存结果
    if args.output and results:
        save_results(results, args.output)

if __name__ == "__main__":
    asyncio.run(main()) 